
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE0_ANNICK(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SDRAM //////////
	DRAM_ADDR,
	DRAM_BA,
	DRAM_CAS_N,
	DRAM_CKE,
	DRAM_CLK,
	DRAM_CS_N,
	DRAM_DQ,
	DRAM_DQM,
	DRAM_RAS_N,
	DRAM_WE_N,

	//////////// EPCS //////////
	EPCS_ASDO,
	EPCS_DATA0,
	EPCS_DCLK,
	EPCS_NCSO,

	//////////// EEPROM //////////
	I2C_SCLK,
	I2C_SDAT,

	//////////// ADC //////////
	ADC_CS_N,
	ADC_SADDR,
	ADC_SCLK,
	ADC_SDAT,

	//////////// 2x13 GPIO Header //////////
	GPIO_2,
	GPIO_2_IN,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	GPIO_0,
	GPIO_0_IN,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	GPIO_1,
	GPIO_1_IN 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// SW //////////
input 		     [3:0]		SW;

//////////// SDRAM //////////
output		    [12:0]		DRAM_ADDR;
output		     [1:0]		DRAM_BA;
output		          		DRAM_CAS_N;
output		          		DRAM_CKE;
output		          		DRAM_CLK;
output		          		DRAM_CS_N;
inout 		    [15:0]		DRAM_DQ;
output		     [1:0]		DRAM_DQM;
output		          		DRAM_RAS_N;
output		          		DRAM_WE_N;

//////////// EPCS //////////
output		          		EPCS_ASDO;
input 		          		EPCS_DATA0;
output		          		EPCS_DCLK;
output		          		EPCS_NCSO;

//////////// EEPROM ////////
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// ADC //////////
output		          		ADC_CS_N;
output		          		ADC_SADDR;
output		          		ADC_SCLK;
input 		          		ADC_SDAT;

//////////// 2x13 GPIO Header //////////
inout 		    [12:0]		GPIO_2;
input 		     [2:0]		GPIO_2_IN;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout 		    [33:0]		GPIO_0;
input 		     [1:0]		GPIO_0_IN;

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout 		    [33:0]		GPIO_1;
input 		     [1:0]		GPIO_1_IN;


//=======================================================
//  Structural coding
//=======================================================

//////// Reset //////////

logic reset;

//////// Stored Data assignement SENSORS //////////

logic [31:0] Odometre_Left, Odometre_Right;

always_comb begin
	case(AddrFromPi[7:4])
		4'hf : DataToPI = 32'h0f0f0f0f;		//TEST
		4'he : DataToPI = 32'h1234abcd;		//TEST

		4'h1 : DataToPI = Odometre_Right;  	// Odomètre gauche 	: 1x
		4'h2 : DataToPI = Odometre_Left; 	// Odomètre droit 	: 2x
		4'h3 : DataToPI = IR1_ext;				// IR1
		4'h4 : DataToPI = IR2_ext;				// IR2
		4'h5 : DataToPI = IR3;				// IR3
		4'h6 : DataToPI = IR4;				// IR4

		default : DataToPI = 32'bx; 		
	endcase
end

//////// Data assignement for ACTUATORS //////////

logic [31:0] Actuators_RAM[15:0];

always_ff @(posedge CLOCK_50) begin
	Actuators_RAM[AddrFromPi[3:0]] = DataFromPI;  
end

assign reset = Actuators_RAM[0][0];	// Reset

assign Servo_control_LC = Actuators_RAM[1];		// Servo pince gauche 	: x1 
assign Servo_control_LP = Actuators_RAM[2];		// Servo pince droite 	: x2
assign Servo_control_RC = Actuators_RAM[3];		// Servo pince gauche 	: x3
assign Servo_control_RP = Actuators_RAM[4];		// Servo pince droite 	: x4
assign stepper_control_L  = Actuators_RAM[5]; 	// Steppers 	  		: x5
assign stepper_control_R  = Actuators_RAM[6]; 	// Steppers 	  		: x6



// ---  SPI module instantiation ---------------------------------------------

logic spi_clk, spi_cs, spi_mosi, spi_miso;
logic [31:0] DataFromPI;
logic [31:0] DataToPI;
logic [7:0]  AddrFromPi;

spi_slave spi_slave_inst (
	.SPI_CLK(spi_clk),
	.SPI_CS(spi_cs),
	.SPI_MOSI(spi_mosi),
	.SPI_MISO(spi_miso),
	.Data_Addr(AddrFromPi),
	.Data_Write(DataToPI),
	.Data_Read(DataFromPI), 
	.Clk(CLOCK_50)
);


// ---  odometer module instantiation  ---------------------------------------

logic odoLA, odoLB, odoRA, odoRB;

odometer odoL (
	.reset(reset),
	.A(odoLA),
	.B(odoLB),
	.distance(Odometre_Left)
);
odometer odoR (
	.reset(reset),
	.A(odoRA),
	.B(odoRB),
	.distance(Odometre_Right)
);


// ---  Servo  instantation    -----------------------------------------------

logic [31:0] Servo_control_LC, Servo_control_LP, Servo_control_RC, Servo_control_RP; 
logic servo_LC, servo_LP, servo_RC, servo_RP;

Servo_PWM SERVO_LC (
	.clk(CLOCK_50), 
	.control(Servo_control_LC), 
	.servo(servo_LC) 
); 
Servo_PWM SERVO_LP (
	.clk(CLOCK_50), 
	.control(Servo_control_LP), 
	.servo(servo_LP)
); 
Servo_PWM SERVO_RC (
	.clk(CLOCK_50), 
	.control(Servo_control_RC), 
	.servo(servo_RC)
); 
Servo_PWM SERVO_RP (
	.clk(CLOCK_50), 
	.control(Servo_control_RP), 
	.servo(servo_RP)
); 

// TEST servo
//assign Servo_control_LC = 32'd25000; //0 def;
/*
logic [19:0] counter1;
logic toggle; 
always_ff @(posedge CLOCK_50) begin
	if(Servo_control_LC == 'd50000)
		toggle <= 0;
	if(Servo_control_LC == 0)
		toggle <= 1; 

	counter1 <= counter1 + 1;
	if(counter1 == 0)
	begin
		if(toggle == 0)
			Servo_control_LC <= Servo_control_LC - 1000;
		if(toggle == 1)
			Servo_control_LC <= Servo_control_LC + 1000;
	end

end 
*/

// ---  IR   instantation      -----------------------------------------------

// generating 2.5 MHz ADC clock from 50 MHz clock
logic [4:0] counter_CLOCK_50;
always_ff @(posedge CLOCK_50) begin
		counter_CLOCK_50 <= counter_CLOCK_50 + 1;
	end

assign clk_1_5 = counter_CLOCK_50[4];




logic [11:0]   IR1, IR2, IR3, IR4;	// IR sensors
logic [31:0]   IR1_ext, IR2_ext, IR3_ext, IR4_ext;	// IR sensors extended to 32 bits

ADC_interface ADC_interface_inst (
	.clk(clk_1_5),
	.ADC_Dout(ADC_SDAT),
	.ADC_Din(ADC_SADDR),
	.ADC_CS(ADC_CS_N),
	.ADC_clk(ADC_SCLK),
	.ADC_0(IR1),
	.ADC_1(IR2),
	.ADC_2(IR3),
	.ADC_3(IR4)
);

assign IR1_ext = {20'b0, IR1};
assign IR2_ext = {20'b0, IR2};
assign IR3_ext = {20'b0, IR3};
assign IR4_ext = {20'b0, IR4};



// ---  Micro-swith instantation ---------------------------------------------
// ---  Stepper instantation   -----------------------------------------------
/*
logic stepper_L, stepper_R, dir_L, dir_R;
logic [31:0] stepper_control_L, stepper_control_R;

stepper stepper_inst_L (
	.clk(CLOCK_50),
	.reset(reset),
	.control(stepper_control_L),
	.step(stepper_L),
	.dir(dir_L)
);

stepper stepper_inst_R (
	.clk(CLOCK_50),
	.reset(reset),
	.control(stepper_control_R),
	.step(stepper_R),
	.dir(dir_R)
);
*/


//////////// Pin assignment for DE0_ANNICK //////////

//---SPI---//
assign spi_clk  		= GPIO_0[11];			//  11 (EDS Setup)
assign spi_cs   		= GPIO_0[9];			//  9  (EDS Setuo)
assign spi_mosi     	= GPIO_0[15];			//  15 (EDS Setup)
assign GPIO_0[13] = spi_cs ? 1'bz : spi_miso ;  //  13 (EDS Setup)

//---Odomètre---//
assign odoLA     = GPIO_0[17];
assign odoLB     = GPIO_0[19];
assign odoRA     = GPIO_0[16];
assign odoRB     = GPIO_0[18];

//---Servo---//
assign GPIO_1[1]  = servo_LC; 
assign GPIO_1[2]  = servo_LP; 
assign GPIO_1[3]  = servo_RC; 
assign GPIO_1[4]  = servo_RP; 




endmodule
